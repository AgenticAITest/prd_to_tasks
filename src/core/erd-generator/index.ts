import type { Entity, Field, Relationship, DataType } from '@/types/entity';
import type { ERDSchema, DBMLGenerationOptions, ERDValidationResult, ERDValidationIssue } from '@/types/erd';
import { generateId } from '@/lib/utils';

const DEFAULT_OPTIONS: DBMLGenerationOptions = {
  includeAuditFields: true,
  includeSoftDelete: true,
  includeIndexes: true,
  includeEnums: true,
  includeNotes: true,
  namingConvention: 'snake_case',
  schemaName: 'public',
};

// Map internal data types to PostgreSQL types
const DATA_TYPE_MAP: Record<DataType, string> = {
  string: 'varchar(255)',
  text: 'text',
  integer: 'integer',
  bigint: 'bigint',
  decimal: 'decimal(18,2)',
  boolean: 'boolean',
  date: 'date',
  datetime: 'timestamp',
  timestamp: 'timestamp',
  uuid: 'uuid',
  json: 'jsonb',
  enum: 'varchar(50)',
  binary: 'bytea',
};

export function generateDBML(
  entities: Entity[],
  relationships: Relationship[],
  options: Partial<DBMLGenerationOptions> = {}
): string {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const lines: string[] = [];

  // Add project header
  lines.push('// Generated by PRD-to-Tasks Converter');
  lines.push(`// Generated at: ${new Date().toISOString()}`);
  lines.push('');

  // Add project block if schema name is provided
  if (opts.schemaName) {
    lines.push(`Project ${opts.schemaName} {`);
    lines.push('  database_type: \'PostgreSQL\'');
    lines.push('  Note: \'Auto-generated from PRD analysis\'');
    lines.push('}');
    lines.push('');
  }

  // Generate enum definitions
  if (opts.includeEnums) {
    const enums = extractEnumsFromEntities(entities);
    enums.forEach((enumDef) => {
      lines.push(`Enum ${enumDef.name} {`);
      enumDef.values.forEach((value) => {
        lines.push(`  ${value}`);
      });
      lines.push('}');
      lines.push('');
    });
  }

  // Generate table definitions
  entities.forEach((entity) => {
    lines.push(...generateTableDefinition(entity, opts));
    lines.push('');
  });

  // Generate relationship references
  relationships.forEach((rel) => {
    lines.push(generateRelationshipRef(rel));
  });

  return lines.join('\n');
}

function generateTableDefinition(entity: Entity, options: DBMLGenerationOptions): string[] {
  const lines: string[] = [];

  // Table header with note
  if (options.includeNotes && entity.description) {
    lines.push(`// ${entity.description}`);
  }
  lines.push(`Table ${entity.tableName} {`);

  // Generate fields
  entity.fields.forEach((field) => {
    const fieldLine = generateFieldDefinition(field, options);
    lines.push(`  ${fieldLine}`);
  });

  // Add indexes block if there are indexed fields
  if (options.includeIndexes) {
    const indexedFields = entity.fields.filter(
      (f) => f.constraints.indexed && !f.constraints.primaryKey && !f.constraints.unique
    );
    if (indexedFields.length > 0) {
      lines.push('');
      lines.push('  indexes {');
      indexedFields.forEach((field) => {
        lines.push(`    ${field.columnName}`);
      });
      // Add composite indexes for common patterns
      if (entity.isAuditable) {
        lines.push('    (created_at, id)');
      }
      lines.push('  }');
    }
  }

  // Add table note
  if (options.includeNotes) {
    lines.push('');
    lines.push(`  Note: 'Entity type: ${entity.type}'`);
  }

  lines.push('}');
  return lines;
}

function generateFieldDefinition(field: Field, options: DBMLGenerationOptions): string {
  const parts: string[] = [];

  // Column name and type
  const dataType = DATA_TYPE_MAP[field.dataType] || 'varchar(255)';
  parts.push(`${field.columnName} ${dataType}`);

  // Constraints
  const constraints: string[] = [];

  if (field.constraints.primaryKey) {
    constraints.push('pk');
  }
  if (field.constraints.unique && !field.constraints.primaryKey) {
    constraints.push('unique');
  }
  if (!field.constraints.nullable) {
    constraints.push('not null');
  }
  if (field.defaultValue !== undefined) {
    const defaultVal = formatDefaultValue(field.defaultValue, field.dataType);
    constraints.push(`default: ${defaultVal}`);
  }
  if (options.includeNotes && field.displayName && field.displayName !== field.columnName) {
    constraints.push(`note: '${field.displayName}'`);
  }

  if (constraints.length > 0) {
    parts.push(`[${constraints.join(', ')}]`);
  }

  return parts.join(' ');
}

function formatDefaultValue(value: unknown, dataType: DataType): string {
  if (value === null) return 'null';

  switch (dataType) {
    case 'string':
    case 'text':
    case 'enum':
      return `'${value}'`;
    case 'boolean':
      return value ? 'true' : 'false';
    case 'timestamp':
      if (value === 'now') return '`now()`';
      return `'${value}'`;
    case 'uuid':
      if (value === 'gen_random_uuid') return '`gen_random_uuid()`';
      return `'${value}'`;
    default:
      return String(value);
  }
}

function generateRelationshipRef(rel: Relationship): string {
  // DBML relationship syntax: Ref: from_table.from_field > to_table.to_field
  const cardinality = getDBMLCardinality(rel.type);
  return `Ref: ${toSnakeCase(rel.from.entity)}.${toSnakeCase(rel.from.field)} ${cardinality} ${toSnakeCase(rel.to.entity)}.${toSnakeCase(rel.to.field)}`;
}

function getDBMLCardinality(relType: string): string {
  switch (relType) {
    case 'one-to-one':
      return '-';
    case 'one-to-many':
      return '<';
    case 'many-to-one':
      return '>';
    case 'many-to-many':
      return '<>';
    default:
      return '>';
  }
}

function extractEnumsFromEntities(entities: Entity[]): { name: string; values: string[] }[] {
  const enums: { name: string; values: string[] }[] = [];
  const seenEnums = new Set<string>();

  entities.forEach((entity) => {
    entity.fields.forEach((field) => {
      if (field.dataType === 'enum' && field.enumValues && field.enumValues.length > 0) {
        const enumName = `${entity.tableName}_${field.columnName}_enum`;
        if (!seenEnums.has(enumName)) {
          seenEnums.add(enumName);
          enums.push({
            name: enumName,
            values: field.enumValues,
          });
        }
      }
    });
  });

  return enums;
}

export function validateERD(
  entities: Entity[],
  relationships: Relationship[]
): ERDValidationResult {
  const issues: ERDValidationIssue[] = [];

  // Check for duplicate table names
  const tableNames = new Set<string>();
  entities.forEach((entity) => {
    if (tableNames.has(entity.tableName)) {
      issues.push({
        id: generateId(),
        type: 'error',
        entityId: entity.id,
        message: `Duplicate table name: ${entity.tableName}`,
        suggestion: 'Rename one of the tables to avoid conflicts',
      });
    }
    tableNames.add(entity.tableName);
  });

  // Check for entities without primary key
  entities.forEach((entity) => {
    const hasPK = entity.fields.some((f) => f.constraints.primaryKey);
    if (!hasPK) {
      issues.push({
        id: generateId(),
        type: 'error',
        entityId: entity.id,
        message: `Entity "${entity.name}" has no primary key`,
        suggestion: 'Add an "id" field with primaryKey constraint',
      });
    }
  });

  // Check for duplicate column names within entity
  entities.forEach((entity) => {
    const columnNames = new Set<string>();
    entity.fields.forEach((field) => {
      if (columnNames.has(field.columnName)) {
        issues.push({
          id: generateId(),
          type: 'error',
          entityId: entity.id,
          fieldId: field.id,
          message: `Duplicate column name "${field.columnName}" in ${entity.name}`,
          suggestion: 'Rename one of the columns',
        });
      }
      columnNames.add(field.columnName);
    });
  });

  // Validate relationships reference existing entities
  const entityNames = new Set(entities.map((e) => e.name.toLowerCase()));
  relationships.forEach((rel) => {
    if (!entityNames.has(rel.from.entity.toLowerCase())) {
      issues.push({
        id: generateId(),
        type: 'error',
        relationshipId: rel.id,
        message: `Relationship references non-existent entity: ${rel.from.entity}`,
        suggestion: 'Create the missing entity or update the relationship',
      });
    }
    if (!entityNames.has(rel.to.entity.toLowerCase())) {
      issues.push({
        id: generateId(),
        type: 'error',
        relationshipId: rel.id,
        message: `Relationship references non-existent entity: ${rel.to.entity}`,
        suggestion: 'Create the missing entity or update the relationship',
      });
    }
  });

  // Validate relationship fields exist
  relationships.forEach((rel) => {
    const fromEntity = entities.find(
      (e) => e.name.toLowerCase() === rel.from.entity.toLowerCase()
    );
    const toEntity = entities.find(
      (e) => e.name.toLowerCase() === rel.to.entity.toLowerCase()
    );

    if (fromEntity) {
      const hasFromField = fromEntity.fields.some(
        (f) => f.name.toLowerCase() === rel.from.field.toLowerCase()
      );
      if (!hasFromField) {
        issues.push({
          id: generateId(),
          type: 'warning',
          relationshipId: rel.id,
          message: `Relationship field "${rel.from.field}" not found in ${rel.from.entity}`,
          suggestion: `Add field "${rel.from.field}" to ${rel.from.entity}`,
        });
      }
    }

    if (toEntity) {
      const hasToField = toEntity.fields.some(
        (f) => f.name.toLowerCase() === rel.to.field.toLowerCase()
      );
      if (!hasToField) {
        issues.push({
          id: generateId(),
          type: 'warning',
          relationshipId: rel.id,
          message: `Relationship field "${rel.to.field}" not found in ${rel.to.entity}`,
          suggestion: `Add field "${rel.to.field}" to ${rel.to.entity}`,
        });
      }
    }
  });

  // Check for missing audit fields (warning)
  entities.forEach((entity) => {
    if (entity.isAuditable) {
      const auditFields = ['created_at', 'updated_at'];
      auditFields.forEach((auditField) => {
        const hasField = entity.fields.some((f) => f.columnName === auditField);
        if (!hasField) {
          issues.push({
            id: generateId(),
            type: 'warning',
            entityId: entity.id,
            message: `Auditable entity "${entity.name}" is missing ${auditField} field`,
            suggestion: `Add ${auditField} timestamp field`,
          });
        }
      });
    }
  });

  // Check for orphan entities (no relationships)
  const entitiesInRelationships = new Set<string>();
  relationships.forEach((rel) => {
    entitiesInRelationships.add(rel.from.entity.toLowerCase());
    entitiesInRelationships.add(rel.to.entity.toLowerCase());
  });

  entities.forEach((entity) => {
    if (
      entities.length > 1 &&
      !entitiesInRelationships.has(entity.name.toLowerCase()) &&
      entity.type !== 'lookup' &&
      entity.type !== 'reference'
    ) {
      issues.push({
        id: generateId(),
        type: 'info',
        entityId: entity.id,
        message: `Entity "${entity.name}" has no relationships to other entities`,
        suggestion: 'Consider if this entity should be related to others',
      });
    }
  });

  const errors = issues
    .filter((i) => i.type === 'error')
    .map((i) => ({
      type: 'missing-required' as const,
      entity: i.entityId,
      field: i.fieldId,
      message: i.message,
    }));

  const warnings = issues
    .filter((i) => i.type === 'warning')
    .map((i) => ({
      type: 'naming-suggestion' as const,
      entity: i.entityId,
      field: i.fieldId,
      message: i.message,
      suggestion: i.suggestion,
    }));

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
  };
}

export function createERDSchema(
  entities: Entity[],
  relationships: Relationship[],
  options: Partial<DBMLGenerationOptions> = {}
): ERDSchema {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const validation = validateERD(entities, relationships);
  const dbml = generateDBML(entities, relationships, opts);

  return {
    id: generateId(),
    projectId: '',
    entities,
    relationships,
    dbml,
    generationOptions: opts,
    validation,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
}

export function applyNamingConvention(
  entities: Entity[],
  convention: 'snake_case' | 'camelCase' | 'PascalCase'
): Entity[] {
  return entities.map((entity) => ({
    ...entity,
    tableName: convertCase(entity.name, convention),
    fields: entity.fields.map((field) => ({
      ...field,
      columnName: convertCase(field.name, convention),
    })),
  }));
}

function convertCase(str: string, convention: 'snake_case' | 'camelCase' | 'PascalCase'): string {
  switch (convention) {
    case 'snake_case':
      return toSnakeCase(str);
    case 'camelCase':
      return toCamelCase(str);
    case 'PascalCase':
      return toPascalCase(str);
    default:
      return str;
  }
}

function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, '_$1')
    .toLowerCase()
    .replace(/^_/, '')
    .replace(/-/g, '_');
}

function toCamelCase(str: string): string {
  return str
    .replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())
    .replace(/^([A-Z])/, (_, letter) => letter.toLowerCase());
}

function toPascalCase(str: string): string {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

export function generateMigrationSQL(
  entities: Entity[],
  relationships: Relationship[],
  schemaName: string = 'public'
): string {
  const lines: string[] = [];

  lines.push('-- Migration generated by PRD-to-Tasks Converter');
  lines.push(`-- Generated at: ${new Date().toISOString()}`);
  lines.push('');
  lines.push('BEGIN;');
  lines.push('');

  // Create tables
  entities.forEach((entity) => {
    lines.push(`-- Create ${entity.name} table`);
    lines.push(`CREATE TABLE IF NOT EXISTS ${schemaName}.${entity.tableName} (`);

    const fieldDefs = entity.fields.map((field) => {
      const parts: string[] = [];
      parts.push(`  ${field.columnName}`);
      parts.push(DATA_TYPE_MAP[field.dataType] || 'varchar(255)');

      if (field.constraints.primaryKey) {
        parts.push('PRIMARY KEY');
      }
      if (!field.constraints.nullable) {
        parts.push('NOT NULL');
      }
      if (field.constraints.unique && !field.constraints.primaryKey) {
        parts.push('UNIQUE');
      }
      if (field.defaultValue !== undefined) {
        const defaultVal = formatSQLDefaultValue(field.defaultValue, field.dataType);
        parts.push(`DEFAULT ${defaultVal}`);
      }

      return parts.join(' ');
    });

    lines.push(fieldDefs.join(',\n'));
    lines.push(');');
    lines.push('');
  });

  // Create indexes
  entities.forEach((entity) => {
    const indexedFields = entity.fields.filter(
      (f) => f.constraints.indexed && !f.constraints.primaryKey && !f.constraints.unique
    );
    indexedFields.forEach((field) => {
      lines.push(
        `CREATE INDEX IF NOT EXISTS idx_${entity.tableName}_${field.columnName} ON ${schemaName}.${entity.tableName}(${field.columnName});`
      );
    });
  });

  if (entities.some((e) => e.fields.some((f) => f.constraints.indexed))) {
    lines.push('');
  }

  // Create foreign key constraints
  relationships.forEach((rel) => {
    const constraintName = `fk_${toSnakeCase(rel.from.entity)}_${toSnakeCase(rel.from.field)}`;
    lines.push(
      `ALTER TABLE ${schemaName}.${toSnakeCase(rel.from.entity)} ADD CONSTRAINT ${constraintName} FOREIGN KEY (${toSnakeCase(rel.from.field)}) REFERENCES ${schemaName}.${toSnakeCase(rel.to.entity)}(${toSnakeCase(rel.to.field)});`
    );
  });

  lines.push('');
  lines.push('COMMIT;');

  return lines.join('\n');
}

function formatSQLDefaultValue(value: unknown, dataType: DataType): string {
  if (value === null) return 'NULL';

  switch (dataType) {
    case 'string':
    case 'text':
    case 'enum':
      return `'${value}'`;
    case 'boolean':
      return value ? 'TRUE' : 'FALSE';
    case 'timestamp':
      if (value === 'now') return 'NOW()';
      return `'${value}'`;
    case 'uuid':
      if (value === 'gen_random_uuid') return 'gen_random_uuid()';
      return `'${value}'`;
    default:
      return String(value);
  }
}
