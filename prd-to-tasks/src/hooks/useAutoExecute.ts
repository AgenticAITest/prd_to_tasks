/**
 * Auto-Execute Hook
 * Handles automatic execution of tasks in sequence
 */

import { generateCodeForTask } from '@/core/code-generator';
import { pushFilesToRepo } from '@/core/environment/github-client';
import { useEntityStore } from '@/store/entityStore';
import { useEnvironmentStore } from '@/store/environmentStore';
import { useERDStore } from '@/store/erdStore';
import { useExecutionStore } from '@/store/executionStore';
import { useIntegrationStore } from '@/store/integrationStore';
import { useTaskStore } from '@/store/taskStore';
import type { GeneratedFile as EnvironmentGeneratedFile } from '@/types/environment';
import type { ProgrammableTask } from '@/types/task';
import { useCallback, useRef } from 'react';
import { toast } from 'sonner';

const DELAY_BETWEEN_TASKS = 10000; // 10 seconds between tasks for GitHub propagation

// Helper to format elapsed time
function formatElapsed(startTime: number): string {
  const elapsed = Math.round((Date.now() - startTime) / 1000);
  return `${elapsed}s`;
}

export function useAutoExecute() {
  const abortRef = useRef(false);

  // Stores
  const tasks = useTaskStore((s) => s.tasks);
  const environment = useEnvironmentStore((s) => s.environment);
  const { apiKeys } = useIntegrationStore();
  const { entities, relationships } = useEntityStore();
  const { dbml } = useERDStore();

  const {
    autoExecuteStatus,
    autoExecuteCurrentTaskId,
    autoExecuteProgress,
    autoExecuteError,
    autoExecuteLog,
    startAutoExecute,
    setAutoExecuteTask,
    pauseAutoExecuteForManual,
    pauseAutoExecuteForError,
    resumeAutoExecute,
    stopAutoExecute,
    completeAutoExecute,
    addAutoExecuteLog,
    setTaskStatus,
    markTaskCommitted,
    markTaskSkipped,
  } = useExecutionStore();

  // Sort tasks by dependencies (simple topological sort)
  const getSortedTasks = useCallback((): ProgrammableTask[] => {
    const taskMap = new Map(tasks.map((t) => [t.id, t]));
    const visited = new Set<string>();
    const result: ProgrammableTask[] = [];

    const visit = (task: ProgrammableTask) => {
      if (visited.has(task.id)) return;
      visited.add(task.id);

      // Visit dependencies first
      for (const depId of task.dependencies) {
        const depTask = taskMap.get(depId);
        if (depTask) {
          visit(depTask);
        }
      }

      result.push(task);
    };

    for (const task of tasks) {
      visit(task);
    }

    return result;
  }, [tasks]);

  // Execute a single code-generation task
  const executeCodeGenTask = useCallback(
    async (task: ProgrammableTask): Promise<{ success: boolean; error?: string }> => {
      const taskStart = Date.now();
      console.log(`[Auto-Execute] ▶ Starting task: ${task.title}`);
      toast.loading(`Generating code for: ${task.title}`, { id: 'auto-execute-status' });

      // Generate code
      const genStart = Date.now();
      console.log(`[Auto-Execute]   → Code generation started...`);

      const result = await generateCodeForTask({
        task,
        projectName: environment?.projectName || 'project',
        entities,
        relationships,
        dbml: dbml || '',
        onProgress: (progress, message) => {
          console.log(`[Auto-Execute]   → [${progress}%] ${message} (${formatElapsed(genStart)})`);
        },
      });

      console.log(`[Auto-Execute]   → Code generation finished (${formatElapsed(genStart)})`);

      if (!result.success) {
        toast.dismiss('auto-execute-status');
        return { success: false, error: result.error || 'Code generation failed' };
      }

      if (result.files.length === 0) {
        toast.dismiss('auto-execute-status');
        return { success: false, error: 'No files generated' };
      }

      console.log(`[Auto-Execute]   → Generated ${result.files.length} file(s)`);

      // Auto-approve all files
      const filesToPush: EnvironmentGeneratedFile[] = result.files.map((f) => ({
        path: f.path,
        content: f.content,
      }));

      // Commit to GitHub
      if (!environment?.github || !apiKeys.github) {
        toast.dismiss('auto-execute-status');
        return { success: false, error: 'GitHub not configured' };
      }

      try {
        const commitStart = Date.now();
        console.log(`[Auto-Execute]   → Pushing to GitHub...`);
        toast.loading(`Committing to GitHub: ${task.title}`, { id: 'auto-execute-status' });

        await pushFilesToRepo(
          apiKeys.github,
          environment.github.owner,
          environment.github.repoName,
          filesToPush,
          `feat(${task.module}): ${task.title}\n\nTask ID: ${task.id}\nAuto-generated by PRD-to-Tasks`,
          environment.github.defaultBranch
        );

        console.log(`[Auto-Execute]   → GitHub push complete (${formatElapsed(commitStart)})`);
        console.log(`[Auto-Execute] ✓ Task complete: ${task.title} (total: ${formatElapsed(taskStart)})`);
        toast.dismiss('auto-execute-status');

        return { success: true };
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Commit failed';
        console.log(`[Auto-Execute]   ✗ GitHub push failed: ${message}`);
        toast.dismiss('auto-execute-status');
        return { success: false, error: message };
      }
    },
    [environment, apiKeys, entities, relationships, dbml]
  );

  // Get the next task to execute (finds first non-completed task)
  // NOTE: We read fresh state from the store to avoid stale closure issues
  const getNextTask = useCallback(
    (sortedTasks: ProgrammableTask[], startFromId?: string): ProgrammableTask | null => {
      // Get fresh status from the store (not from closure)
      const freshStatus = useExecutionStore.getState().taskExecutionStatus;

      let startIndex = 0;

      if (startFromId) {
        const idx = sortedTasks.findIndex((t) => t.id === startFromId);
        if (idx !== -1) {
          // Check if current task is manual and completed, then move to next
          const currentTask = sortedTasks[idx];
          const currentStatus = freshStatus[currentTask.id];
          if (currentStatus === 'manual-complete' || currentStatus === 'committed' || currentStatus === 'skipped') {
            startIndex = idx + 1;
          } else {
            startIndex = idx;
          }
        }
      }

      for (let i = startIndex; i < sortedTasks.length; i++) {
        const task = sortedTasks[i];
        const status = freshStatus[task.id];

        // Skip already completed tasks
        if (status === 'committed' || status === 'skipped' || status === 'manual-complete') {
          continue;
        }

        return task;
      }

      return null;
    },
    [] // No dependencies - we read fresh state directly
  );

  // Main execution loop
  const runAutoExecute = useCallback(
    async (startFromTaskId?: string) => {
      abortRef.current = false;
      const sortedTasks = getSortedTasks();

      // Count remaining tasks (get fresh status from store)
      const freshStatus = useExecutionStore.getState().taskExecutionStatus;
      const remainingTasks = sortedTasks.filter((t) => {
        const status = freshStatus[t.id];
        return status !== 'committed' && status !== 'skipped' && status !== 'manual-complete';
      });

      if (remainingTasks.length === 0) {
        toast.info('All tasks already completed!');
        return;
      }

      startAutoExecute(sortedTasks.length);
      console.log(`[Auto-Execute] ═══════════════════════════════════════════`);
      console.log(`[Auto-Execute] Starting auto-execute for ${remainingTasks.length} remaining tasks`);
      console.log(`[Auto-Execute] ═══════════════════════════════════════════`);
      toast.info(`Starting auto-execute for ${remainingTasks.length} remaining tasks`);

      let completedCount = sortedTasks.length - remainingTasks.length;
      let currentTask = getNextTask(sortedTasks, startFromTaskId);

      while (currentTask && !abortRef.current) {
        const taskIndex = sortedTasks.findIndex(t => t.id === currentTask!.id) + 1;
        console.log(`[Auto-Execute] ───────────────────────────────────────────`);
        console.log(`[Auto-Execute] Task ${taskIndex}/${sortedTasks.length}: ${currentTask.title}`);
        setAutoExecuteTask(currentTask.id, completedCount);

        const executionMode = currentTask.executionMode || 'code-generation';
        console.log(`[Auto-Execute]   Mode: ${executionMode}`);

        // Handle based on execution mode
        if (executionMode === 'skip') {
          // Auto-mark skip tasks as verified
          markTaskSkipped(currentTask.id);
          addAutoExecuteLog(currentTask.id, 'skipped', `Skipped: ${currentTask.title}`);
          completedCount++;

          // Small delay
          await new Promise((resolve) => setTimeout(resolve, 500));
        } else if (executionMode === 'manual') {
          // Pause for manual task
          pauseAutoExecuteForManual(currentTask.id);
          addAutoExecuteLog(
            currentTask.id,
            'skipped',
            `Paused for manual task: ${currentTask.title}`
          );
          toast.warning(`Manual task: ${currentTask.title}. Complete it and click Resume.`);
          return; // Exit the loop, will resume later
        } else {
          // Code generation task
          setTaskStatus(currentTask.id, 'generating');

          const result = await executeCodeGenTask(currentTask);

          if (abortRef.current) {
            addAutoExecuteLog(currentTask.id, 'error', 'Execution stopped by user');
            break;
          }

          if (result.success) {
            markTaskCommitted(currentTask.id);
            addAutoExecuteLog(currentTask.id, 'success', `Completed: ${currentTask.title}`);
            completedCount++;
            toast.success(`Committed: ${currentTask.title}`);
          } else {
            // Error - pause execution
            pauseAutoExecuteForError(currentTask.id, result.error || 'Unknown error');
            addAutoExecuteLog(
              currentTask.id,
              'error',
              `Error: ${result.error || 'Unknown error'}`
            );
            toast.error(`Error on ${currentTask.title}: ${result.error}`);
            return; // Exit the loop
          }
        }

        // Delay between tasks
        console.log(`[Auto-Execute] ⏳ Waiting ${DELAY_BETWEEN_TASKS / 1000}s before next task...`);
        toast.loading(`Waiting ${DELAY_BETWEEN_TASKS / 1000}s before next task...`, { id: 'auto-execute-status', duration: DELAY_BETWEEN_TASKS });
        await new Promise((resolve) => setTimeout(resolve, DELAY_BETWEEN_TASKS));
        toast.dismiss('auto-execute-status');

        // Get next task
        currentTask = getNextTask(sortedTasks, currentTask.id);
      }

      if (!abortRef.current) {
        completeAutoExecute();
        toast.success('Auto-execute completed!');
      }
    },
    [
      getSortedTasks,
      startAutoExecute,
      getNextTask,
      setAutoExecuteTask,
      markTaskSkipped,
      addAutoExecuteLog,
      pauseAutoExecuteForManual,
      setTaskStatus,
      executeCodeGenTask,
      markTaskCommitted,
      pauseAutoExecuteForError,
      completeAutoExecute,
    ]
  );

  // Start auto-execute
  const start = useCallback(() => {
    runAutoExecute();
  }, [runAutoExecute]);

  // Resume after manual task or error
  const resume = useCallback(() => {
    resumeAutoExecute();
    runAutoExecute(autoExecuteCurrentTaskId || undefined);
  }, [resumeAutoExecute, runAutoExecute, autoExecuteCurrentTaskId]);

  // Stop execution
  const stop = useCallback(() => {
    abortRef.current = true;
    stopAutoExecute();
    toast.info('Auto-execute stopped');
  }, [stopAutoExecute]);

  return {
    // State
    status: autoExecuteStatus,
    currentTaskId: autoExecuteCurrentTaskId,
    progress: autoExecuteProgress,
    error: autoExecuteError,
    log: autoExecuteLog,

    // Actions
    start,
    resume,
    stop,

    // Computed
    isRunning: autoExecuteStatus === 'running',
    isPaused: autoExecuteStatus === 'paused-manual' || autoExecuteStatus === 'paused-error',
    isCompleted: autoExecuteStatus === 'completed',
  };
}
