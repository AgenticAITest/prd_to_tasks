/**
 * PERN Project Scaffold Generator
 * Generates a complete PERN (PostgreSQL, Express, React, Node) project structure
 */

import type { GeneratedFile, ScaffoldContext } from '@/types/environment';
import type { Entity, DataType } from '@/types/entity';

/**
 * Generate the complete project scaffold
 */
export function generateScaffold(context: ScaffoldContext): GeneratedFile[] {
  const { projectName, entities } = context;
  const files: GeneratedFile[] = [];

  // Root files
  files.push(generateRootPackageJson(projectName));
  files.push(generateGitpodYml());
  files.push(generateEnvExample(projectName));
  files.push(generateRootGitignore());
  files.push(generateReadme(projectName));

  // Backend files
  files.push(generateBackendPackageJson());
  files.push(generateBackendTsConfig());
  files.push(generatePrismaSchema(entities));
  files.push(generateBackendIndex());
  files.push(generateRoutesIndex(entities));

  // Generate a route file for each entity
  for (const entity of entities) {
    files.push(generateEntityRoute(entity));
  }

  // Frontend files
  files.push(generateFrontendPackageJson());
  files.push(generateFrontendTsConfig());
  files.push(generateViteConfig());
  files.push(generateFrontendIndex());
  files.push(generateFrontendMain());
  files.push(generateFrontendApp());
  files.push(generateFrontendCss());

  return files;
}

// ============================================================================
// Root Files
// ============================================================================

function generateRootPackageJson(projectName: string): GeneratedFile {
  const content = {
    name: projectName,
    version: '1.0.0',
    private: true,
    scripts: {
      'install:all': 'npm install && cd backend && npm install && cd ../frontend && npm install',
      dev: 'concurrently "npm run dev:backend" "npm run dev:frontend"',
      'dev:backend': 'cd backend && npm run dev',
      'dev:frontend': 'cd frontend && npm run dev',
      build: 'cd backend && npm run build && cd ../frontend && npm run build',
      'db:push': 'cd backend && npx prisma db push',
      'db:generate': 'cd backend && npx prisma generate',
      'db:studio': 'cd backend && npx prisma studio',
    },
    devDependencies: {
      concurrently: '^8.2.2',
    },
  };

  return {
    path: 'package.json',
    content: JSON.stringify(content, null, 2),
  };
}

function generateGitpodYml(): GeneratedFile {
  const content = `# Gitpod configuration
tasks:
  - name: Install Dependencies
    init: npm run install:all
    command: |
      cd backend && npx prisma generate
      npm run dev

ports:
  - port: 3001
    onOpen: ignore
    visibility: public
    name: Backend API
  - port: 5173
    onOpen: open-preview
    visibility: public
    name: Frontend

vscode:
  extensions:
    - dbaeumer.vscode-eslint
    - esbenp.prettier-vscode
    - Prisma.prisma
`;

  return {
    path: '.gitpod.yml',
    content,
  };
}

function generateEnvExample(projectName: string): GeneratedFile {
  const content = `# Database
DATABASE_URL="postgresql://user:password@host:5432/${projectName}?sslmode=require"

# Backend
PORT=3001
NODE_ENV=development

# Frontend
VITE_API_URL=http://localhost:3001/api
`;

  return {
    path: '.env.example',
    content,
  };
}

function generateRootGitignore(): GeneratedFile {
  const content = `# Dependencies
node_modules/

# Environment
.env
.env.local
.env.*.local

# Build outputs
dist/
build/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Prisma
backend/prisma/migrations/
`;

  return {
    path: '.gitignore',
    content,
  };
}

function generateReadme(projectName: string): GeneratedFile {
  const content = `# ${projectName}

A PERN stack application generated by PRD-to-Tasks.

## Tech Stack

- **PostgreSQL** - Database (via Neon)
- **Express** - Backend API framework
- **React** - Frontend framework
- **Node.js** - Runtime environment
- **Prisma** - Database ORM
- **Vite** - Frontend build tool

## Getting Started

### Prerequisites

- Node.js 18+
- npm or yarn

### Setup

1. Install dependencies:
   \`\`\`bash
   npm run install:all
   \`\`\`

2. Copy environment variables:
   \`\`\`bash
   cp .env.example .env
   \`\`\`

3. Update \`.env\` with your Neon database URL.

4. Generate Prisma client:
   \`\`\`bash
   npm run db:generate
   \`\`\`

5. Push schema to database:
   \`\`\`bash
   npm run db:push
   \`\`\`

### Development

Start both backend and frontend:
\`\`\`bash
npm run dev
\`\`\`

- Backend runs on http://localhost:3001
- Frontend runs on http://localhost:5173

### Useful Commands

- \`npm run db:studio\` - Open Prisma Studio to browse data
- \`npm run build\` - Build for production

## Project Structure

\`\`\`
${projectName}/
├── backend/
│   ├── prisma/
│   │   └── schema.prisma    # Database schema
│   └── src/
│       ├── index.ts         # Express server
│       └── routes/          # API routes
└── frontend/
    └── src/
        ├── App.tsx          # Main React component
        └── main.tsx         # Entry point
\`\`\`
`;

  return {
    path: 'README.md',
    content,
  };
}

// ============================================================================
// Backend Files
// ============================================================================

function generateBackendPackageJson(): GeneratedFile {
  const content = {
    name: 'backend',
    version: '1.0.0',
    private: true,
    type: 'module',
    scripts: {
      dev: 'tsx watch src/index.ts',
      build: 'tsc',
      start: 'node dist/index.js',
    },
    dependencies: {
      '@prisma/client': '^5.8.0',
      cors: '^2.8.5',
      dotenv: '^16.3.1',
      express: '^4.18.2',
      zod: '^3.22.4',
    },
    devDependencies: {
      '@types/cors': '^2.8.17',
      '@types/express': '^4.17.21',
      '@types/node': '^20.10.6',
      prisma: '^5.8.0',
      tsx: '^4.7.0',
      typescript: '^5.3.3',
    },
  };

  return {
    path: 'backend/package.json',
    content: JSON.stringify(content, null, 2),
  };
}

function generateBackendTsConfig(): GeneratedFile {
  const content = {
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'Node',
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
      outDir: './dist',
      rootDir: './src',
      resolveJsonModule: true,
    },
    include: ['src/**/*'],
    exclude: ['node_modules'],
  };

  return {
    path: 'backend/tsconfig.json',
    content: JSON.stringify(content, null, 2),
  };
}

function generatePrismaSchema(entities: Entity[]): GeneratedFile {
  let content = `// Prisma Schema generated by PRD-to-Tasks
// https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

`;

  for (const entity of entities) {
    content += generatePrismaModel(entity);
    content += '\n';
  }

  return {
    path: 'backend/prisma/schema.prisma',
    content,
  };
}

function generatePrismaModel(entity: Entity): string {
  const modelName = toPascalCase(entity.name);
  let model = `model ${modelName} {\n`;

  for (const field of entity.fields) {
    const prismaType = mapToPrismaType(field.dataType, field.constraints.nullable);
    const attributes: string[] = [];

    if (field.constraints.primaryKey) {
      attributes.push('@id');
      if (field.dataType === 'uuid') {
        attributes.push('@default(uuid())');
      } else if (field.dataType === 'integer' || field.dataType === 'bigint') {
        attributes.push('@default(autoincrement())');
      }
    }

    if (field.constraints.unique && !field.constraints.primaryKey) {
      attributes.push('@unique');
    }

    if (field.defaultValue && !field.constraints.primaryKey) {
      if (field.dataType === 'boolean') {
        attributes.push(`@default(${field.defaultValue})`);
      } else if (field.dataType === 'datetime' || field.dataType === 'timestamp') {
        if (field.defaultValue === 'now()' || field.defaultValue === 'CURRENT_TIMESTAMP') {
          attributes.push('@default(now())');
        }
      } else if (field.dataType === 'integer' || field.dataType === 'decimal') {
        attributes.push(`@default(${field.defaultValue})`);
      } else {
        attributes.push(`@default("${field.defaultValue}")`);
      }
    }

    // Map column name if different from field name
    if (field.columnName && field.columnName !== field.name) {
      attributes.push(`@map("${field.columnName}")`);
    }

    const attrStr = attributes.length > 0 ? ' ' + attributes.join(' ') : '';
    model += `  ${field.name} ${prismaType}${attrStr}\n`;
  }

  // Add audit fields if entity is auditable
  if (entity.isAuditable) {
    if (!entity.fields.some(f => f.name === 'createdAt')) {
      model += '  createdAt DateTime @default(now()) @map("created_at")\n';
    }
    if (!entity.fields.some(f => f.name === 'updatedAt')) {
      model += '  updatedAt DateTime @updatedAt @map("updated_at")\n';
    }
  }

  // Map table name
  if (entity.tableName && entity.tableName !== modelName.toLowerCase()) {
    model += `\n  @@map("${entity.tableName}")\n`;
  }

  model += '}\n';
  return model;
}

function mapToPrismaType(dataType: DataType, nullable: boolean): string {
  const suffix = nullable ? '?' : '';

  const typeMap: Record<DataType, string> = {
    string: 'String',
    text: 'String',
    integer: 'Int',
    bigint: 'BigInt',
    decimal: 'Decimal',
    boolean: 'Boolean',
    date: 'DateTime',
    datetime: 'DateTime',
    timestamp: 'DateTime',
    uuid: 'String',
    json: 'Json',
    enum: 'String',
    binary: 'Bytes',
  };

  return (typeMap[dataType] || 'String') + suffix;
}

function generateBackendIndex(): GeneratedFile {
  const content = `import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { PrismaClient } from '@prisma/client';
import routes from './routes/index.js';

dotenv.config();

const app = express();
const port = process.env.PORT || 3001;

// Initialize Prisma
export const prisma = new PrismaClient();

// Middleware
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// API routes
app.use('/api', routes);

// Error handling
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal server error' });
});

// Start server
app.listen(port, () => {
  console.log(\`Backend server running on http://localhost:\${port}\`);
});

// Graceful shutdown
process.on('SIGINT', async () => {
  await prisma.$disconnect();
  process.exit(0);
});
`;

  return {
    path: 'backend/src/index.ts',
    content,
  };
}

function generateRoutesIndex(entities: Entity[]): GeneratedFile {
  const imports = entities
    .map((e) => `import ${toCamelCase(e.name)}Routes from './${toKebabCase(e.name)}.js';`)
    .join('\n');

  const routes = entities
    .map((e) => `router.use('/${toKebabCase(e.name)}', ${toCamelCase(e.name)}Routes);`)
    .join('\n');

  const content = `import { Router } from 'express';
${imports}

const router = Router();

${routes}

export default router;
`;

  return {
    path: 'backend/src/routes/index.ts',
    content,
  };
}

function generateEntityRoute(entity: Entity): GeneratedFile {
  const modelName = toPascalCase(entity.name);
  const routeName = toKebabCase(entity.name);
  const varName = toCamelCase(entity.name);

  const content = `import { Router } from 'express';
import { prisma } from '../index.js';
import { z } from 'zod';

const router = Router();

// Validation schema
const ${varName}Schema = z.object({
${entity.fields
  .filter((f) => !f.constraints.primaryKey && f.name !== 'createdAt' && f.name !== 'updatedAt')
  .map((f) => `  ${f.name}: ${getZodType(f.dataType, f.constraints.nullable)},`)
  .join('\n')}
});

// GET all ${routeName}
router.get('/', async (req, res) => {
  try {
    const items = await prisma.${varName}.findMany();
    res.json(items);
  } catch (error) {
    console.error('Error fetching ${routeName}:', error);
    res.status(500).json({ error: 'Failed to fetch ${routeName}' });
  }
});

// GET single ${routeName} by id
router.get('/:id', async (req, res) => {
  try {
    const item = await prisma.${varName}.findUnique({
      where: { id: req.params.id },
    });
    if (!item) {
      return res.status(404).json({ error: '${modelName} not found' });
    }
    res.json(item);
  } catch (error) {
    console.error('Error fetching ${routeName}:', error);
    res.status(500).json({ error: 'Failed to fetch ${routeName}' });
  }
});

// POST create ${routeName}
router.post('/', async (req, res) => {
  try {
    const data = ${varName}Schema.parse(req.body);
    const item = await prisma.${varName}.create({ data });
    res.status(201).json(item);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: error.errors });
    }
    console.error('Error creating ${routeName}:', error);
    res.status(500).json({ error: 'Failed to create ${routeName}' });
  }
});

// PUT update ${routeName}
router.put('/:id', async (req, res) => {
  try {
    const data = ${varName}Schema.partial().parse(req.body);
    const item = await prisma.${varName}.update({
      where: { id: req.params.id },
      data,
    });
    res.json(item);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: error.errors });
    }
    console.error('Error updating ${routeName}:', error);
    res.status(500).json({ error: 'Failed to update ${routeName}' });
  }
});

// DELETE ${routeName}
router.delete('/:id', async (req, res) => {
  try {
    await prisma.${varName}.delete({
      where: { id: req.params.id },
    });
    res.status(204).send();
  } catch (error) {
    console.error('Error deleting ${routeName}:', error);
    res.status(500).json({ error: 'Failed to delete ${routeName}' });
  }
});

export default router;
`;

  return {
    path: `backend/src/routes/${routeName}.ts`,
    content,
  };
}

function getZodType(dataType: DataType, nullable: boolean): string {
  const baseTypes: Record<DataType, string> = {
    string: 'z.string()',
    text: 'z.string()',
    integer: 'z.number().int()',
    bigint: 'z.bigint()',
    decimal: 'z.number()',
    boolean: 'z.boolean()',
    date: 'z.string().datetime()',
    datetime: 'z.string().datetime()',
    timestamp: 'z.string().datetime()',
    uuid: 'z.string().uuid()',
    json: 'z.record(z.unknown())',
    enum: 'z.string()',
    binary: 'z.instanceof(Buffer)',
  };

  const base = baseTypes[dataType] || 'z.string()';
  return nullable ? `${base}.optional()` : base;
}

// ============================================================================
// Frontend Files
// ============================================================================

function generateFrontendPackageJson(): GeneratedFile {
  const content = {
    name: 'frontend',
    version: '1.0.0',
    private: true,
    type: 'module',
    scripts: {
      dev: 'vite',
      build: 'tsc && vite build',
      preview: 'vite preview',
    },
    dependencies: {
      react: '^18.2.0',
      'react-dom': '^18.2.0',
    },
    devDependencies: {
      '@types/react': '^18.2.48',
      '@types/react-dom': '^18.2.18',
      '@vitejs/plugin-react': '^4.2.1',
      typescript: '^5.3.3',
      vite: '^5.0.12',
    },
  };

  return {
    path: 'frontend/package.json',
    content: JSON.stringify(content, null, 2),
  };
}

function generateFrontendTsConfig(): GeneratedFile {
  const content = {
    compilerOptions: {
      target: 'ES2020',
      useDefineForClassFields: true,
      lib: ['ES2020', 'DOM', 'DOM.Iterable'],
      module: 'ESNext',
      skipLibCheck: true,
      moduleResolution: 'bundler',
      allowImportingTsExtensions: true,
      resolveJsonModule: true,
      isolatedModules: true,
      noEmit: true,
      jsx: 'react-jsx',
      strict: true,
      noUnusedLocals: true,
      noUnusedParameters: true,
      noFallthroughCasesInSwitch: true,
    },
    include: ['src'],
    references: [{ path: './tsconfig.node.json' }],
  };

  return {
    path: 'frontend/tsconfig.json',
    content: JSON.stringify(content, null, 2),
  };
}

function generateViteConfig(): GeneratedFile {
  const content = `import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
});
`;

  return {
    path: 'frontend/vite.config.ts',
    content,
  };
}

function generateFrontendIndex(): GeneratedFile {
  const content = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
`;

  return {
    path: 'frontend/index.html',
    content,
  };
}

function generateFrontendMain(): GeneratedFile {
  const content = `import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

  return {
    path: 'frontend/src/main.tsx',
    content,
  };
}

function generateFrontendApp(): GeneratedFile {
  const content = `import { useState, useEffect } from 'react';

interface HealthStatus {
  status: string;
  timestamp: string;
}

function App() {
  const [health, setHealth] = useState<HealthStatus | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch('/api/../health')
      .then((res) => res.json())
      .then(setHealth)
      .catch((err) => setError(err.message));
  }, []);

  return (
    <div className="app">
      <header>
        <h1>Welcome to Your App</h1>
        <p>Your PERN stack application is ready!</p>
      </header>

      <main>
        <section className="status-card">
          <h2>Backend Status</h2>
          {error ? (
            <p className="error">Error: {error}</p>
          ) : health ? (
            <div>
              <p className="success">Status: {health.status}</p>
              <p>Last checked: {new Date(health.timestamp).toLocaleString()}</p>
            </div>
          ) : (
            <p>Loading...</p>
          )}
        </section>

        <section className="next-steps">
          <h2>Next Steps</h2>
          <ul>
            <li>Review the generated Prisma schema in <code>backend/prisma/schema.prisma</code></li>
            <li>Run <code>npm run db:push</code> to sync the schema with your database</li>
            <li>Use <code>npm run db:studio</code> to browse your data</li>
            <li>Start building your features!</li>
          </ul>
        </section>
      </main>
    </div>
  );
}

export default App;
`;

  return {
    path: 'frontend/src/App.tsx',
    content,
  };
}

function generateFrontendCss(): GeneratedFile {
  const content = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
    Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  background-color: #f5f5f5;
  color: #333;
  line-height: 1.6;
}

.app {
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
}

header {
  text-align: center;
  margin-bottom: 2rem;
}

header h1 {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  color: #2563eb;
}

header p {
  color: #666;
  font-size: 1.1rem;
}

.status-card,
.next-steps {
  background: white;
  border-radius: 8px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

h2 {
  font-size: 1.25rem;
  margin-bottom: 1rem;
  color: #1f2937;
}

.success {
  color: #16a34a;
  font-weight: 500;
}

.error {
  color: #dc2626;
  font-weight: 500;
}

ul {
  list-style-position: inside;
}

li {
  margin-bottom: 0.5rem;
}

code {
  background-color: #f1f5f9;
  padding: 0.125rem 0.375rem;
  border-radius: 4px;
  font-family: monospace;
  font-size: 0.9em;
}
`;

  return {
    path: 'frontend/src/index.css',
    content,
  };
}

// ============================================================================
// Utility Functions
// ============================================================================

function toPascalCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
    .replace(/^(.)/, (_, c) => c.toUpperCase());
}

function toCamelCase(str: string): string {
  return str
    .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
    .replace(/^(.)/, (_, c) => c.toLowerCase());
}

function toKebabCase(str: string): string {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[_\s]/g, '-')
    .toLowerCase();
}
